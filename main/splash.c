#include "sdkconfig.h"
#include "ssd1306.h"
#include "ssd1306-priv.h"

#include <math.h>

#include <esp_random.h>
#include <esp_check.h>
#include <esp_timer.h>

#define TAG                 "SSD1306"
#define SCREEN_SPLASH_FPS   50
#define SCREEN_SPLASH_TICKS pdMS_TO_TICKS(1000/SCREEN_SPLASH_FPS)

const ssd1306_bitmap_t splash_bmp = {
	width: 120,
	height: 24,

	image: {
		// https://javl.github.io/image2cpp/
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x80, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0xf8, 0xfc, 0xfc, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xbc, 0xbc, 
		0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		
		0x00, 0x00, 0x40, 0xfc, 0xfe, 0xff, 0x07, 0x03, 0x03, 0x01, 0x01, 0x03, 0x07, 0xff, 0xff, 0xff,
		0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x3f, 0x7b, 0x71, 0xe3, 0xe7, 0xc3, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xfc, 0xfe, 0x3f, 0x07, 0x03, 0x01, 0x01, 0x01, 0x01, 0x03, 0x07, 0x07, 0x02, 0x00,
		0x00, 0x00, 0xf0, 0xfc, 0xff, 0x77, 0x73, 0x73, 0x73, 0x73, 0x73, 0x77, 0x7f, 0xff, 0x7e, 0x78,
		0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
		0xff, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xfc, 0xfe, 0x1f, 0x07, 0x07, 0x03, 0x03, 0x03, 0x03, 0x03,
		0x07, 0xfe, 0xfc, 0xf0, 0x00, 0x00, 0x00, 0x00,	0xff, 0xff, 0xff, 0x7f, 0x0f, 0x07, 0x03, 0x03,
		0x03, 0x1f, 0xff, 0xfc, 0xf0, 0x00, 0x00, 0x00, 

		0x00, 0x00, 0x00, 0x01, 0x07, 0x0f, 0x0e, 0x1e, 0x1c, 0x1c, 0x1c, 0x1c, 0x0e, 0x0f, 0x3f, 0x1f, 
		0x1f, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x0e, 0x1e, 0x1c, 0x1c, 0x1c, 0x1f, 0x0f, 0x07, 0x00, 0x00, 
		0x00, 0x00, 0x03, 0x07, 0x0f, 0x1c, 0x1c, 0x18, 0x18, 0x38, 0x3c, 0x1c, 0x1e, 0x0e, 0x08, 0x00, 
		0x00, 0x00, 0x01, 0x07, 0x0f, 0x0e, 0x1c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x07, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x1c, 0x3f, 0x3f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x1f, 0x1f, 
		0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0f, 0x1f, 0x1c, 0x1c, 0x18, 0x18, 0x18, 0x18, 0x1c, 
		0x1f, 0x0f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x1f, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x3f, 0x3f, 0x3f, 0x00, 0x00, 0x00
	},
};

const ssd1306_bitmap_t rocket_bmp = {
	width: 16,
	height: 16,
	image: {
		0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x02, 0x91,
		0x02, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 

		0x00, 0x00, 0x00, 0x00, 0x20, 0x13, 0x8c, 0x60,
		0x8c, 0x13, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
	},
};

const ssd1306_bitmap_t bitmap_16x24 = {
	width: 16,
	height: 24,

	image: {
		0x00, 0x00, 0x00, 0x06, 0x03, 0xfe, 0xfc, 0xf8,
		0xf0, 0xe0, 0xc0, 0x81, 0x02, 0x00, 0x00, 0x00,
		
		0x00, 0x00, 0x00, 0x18, 0x99, 0x00, 0x00, 0x00,
		0xc0, 0x30, 0x0c, 0xf3, 0x01, 0x00, 0x00, 0x00,
		
		0x00, 0x00, 0x00, 0x60, 0xc0, 0x30, 0x0c, 0x03,
		0x00, 0xc0, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
	}
};

static TickType_t splash_ticks;

void translate_bitmap(ssd1306_t device, const ssd1306_bitmap_t* bitmap)
{
	const unsigned posX = abs((int)device->width - (int)bitmap->width) / 2;
	const unsigned posY = abs((int)device->height - (int)bitmap->height) / 2;

	ssd1306_bounds_t bounds = {
		x: posX,
		y: posY,
		width: bitmap->width,
		height: bitmap->height,
	};

	const int x0 = -(int)bitmap->width - 1;
	const int x1 = device->width + + 1;

	ssd1306_clear_b(device, NULL);
	ssd1306_auto_update(device, false);
	for( bounds.x = x1, bounds.y = posY; bounds.x >= x0; bounds.x-- ) {
		ssd1306_bitmap_b(device, &bounds, bitmap);
		ssd1306_auto_update(device, true);
		vTaskDelayUntil(&splash_ticks, SCREEN_SPLASH_TICKS);
		ssd1306_auto_update(device, false);
		ssd1306_clear_b(device, &bounds);
		ssd1306_clear(device, 0, device->height - 8, device->width, 8);
	}
	ssd1306_auto_update(device, true);

	const int y0 = -(int)bitmap->height - 1;
	const int y1 = device->height + 1;

	ssd1306_clear_b(device, NULL);
	ssd1306_auto_update(device, false);
	for( bounds.x = posX, bounds.y = y0; bounds.y <= y1; bounds.y++ ) {
		ssd1306_bitmap_b(device, &bounds, bitmap);
		ssd1306_auto_update(device, true);
		vTaskDelayUntil(&splash_ticks, SCREEN_SPLASH_TICKS);
		ssd1306_auto_update(device, false);
		ssd1306_clear_b(device, &bounds);
	}
	ssd1306_auto_update(device, true);

	ssd1306_clear_b(device, NULL);
	ssd1306_bitmap(device, posX, posY, device->width, device->height, bitmap);
	vTaskDelayUntil(&splash_ticks, pdMS_TO_TICKS(2500));
}

void fill_with_random(ssd1306_t device)
{
	ssd1306_acquire(device);
	for( unsigned page = 0; page < device->pages; page++ ) {
		esp_fill_random(raster_page(device, page), device->width);
	}
	ssd1306_release(device);
	ssd1306_update(device);
}

void expand_rectangle(ssd1306_t device)
{
	const unsigned dim = mini(device->width, device->height) / 2 - 1;

	LOG_I("DIM = %u", dim);

	ssd1306_bounds_t bounds = {
		x: dim, y: dim, 
		width: device->width - 2*dim,
		height: device->height - 2*dim,
	};

	while( bounds.x >= 0 && bounds.y >= 0 ) {
		ssd1306_clear_b(device, &bounds);

		vTaskDelayUntil(&splash_ticks, SCREEN_SPLASH_TICKS);

		bounds.x--;
		bounds.y--;
		bounds.width += 2;
		bounds.height += 2;
	}
}

inline int signum_of(int x)
{
	return (x > 0) - (x < 0);
}
inline int random_01()
{
	return esp_random() & 1;
}

void bouncing_bitmap(ssd1306_t device, const ssd1306_bitmap_t* bitmap)
{
	const int x_min = 0;
	const int x_max = device->width - bitmap->width;
	const int y_min = device-> flip || device->height == 32 ? 0 : 16;
	const int y_max = device->height - bitmap->height - (16 - y_min);

	ssd1306_bounds_t bounds = {
		x: x_min + esp_random() % (x_max - x_min),
		y: y_min + esp_random() % (y_max - y_min),
		size: bitmap->size,
	};

	int speed_x = 1 - 2*random_01();
	int speed_y = 1 - 2*random_01();

	const double start_total = esp_timer_get_time();
	double start_local = esp_timer_get_time();

	ssd1306_auto_update(device, false);

	while( true ) {
		double start = esp_timer_get_time();

		if( device->height == 64 ) {
			double diff_total = (start - start_total) / 1E6;
			double diff_local = (start - start_local) / 1E3;

			LOG_I("DIFF %f / %f, %6.2f/%6.2f", diff_total, diff_local, diff_total, diff_local);

			ssd1306_status(device, ssd1306_status_0, "T%1$c%4$6.2f%2$c X%1$c%3$3d%2$c",
				device->text_invert.on, device->text_invert.off, bounds.x, diff_total);
			ssd1306_status(device, ssd1306_status_1, "t%1$c%4$6.2f%2$c Y%1$c%3$3d%2$c",
				device->text_invert.on, device->text_invert.off, bounds.y, diff_local);
		}

		ssd1306_bitmap_b(device, &bounds, bitmap);
		ssd1306_auto_update(device, true);
		vTaskDelayUntil(&splash_ticks, SCREEN_SPLASH_TICKS);
		ssd1306_auto_update(device, false);
		ssd1306_clear_b(device, &bounds);

		bounds.x += speed_x;
		bounds.y += speed_y;

		if( bounds.x < x_min || bounds.x >= x_max ) {
			speed_x = -signum_of(speed_x) * (1 + random_01());
			bounds.x += speed_x;
		}
		if( bounds.y < y_min || bounds.y >= y_max ) {
			speed_y = -signum_of(speed_y) * (1 + random_01());
			bounds.y += speed_y;
		}

		start_local = start;
	}
}

void ssd1306_show_splash(ssd1306_t device)
{
	splash_ticks = xTaskGetTickCount();

	ssd1306_clear_b(device, NULL);
	vTaskDelayUntil(&splash_ticks, pdMS_TO_TICKS(2500));
	fill_with_random(device);
	expand_rectangle(device);
	vTaskDelayUntil(&splash_ticks, pdMS_TO_TICKS(250));

	ssd1306_clear_b(device, NULL);
	translate_bitmap(device, &splash_bmp);
	vTaskDelayUntil(&splash_ticks, pdMS_TO_TICKS(1000));

	// ssd1306_clear_b(device, NULL);
	// bouncing_bitmap(device, &rocket_bmp);
}
